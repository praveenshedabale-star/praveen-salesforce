Trigger 1:
//When case is created or updated with priority as High, update the custom field High priority case count field on
//Account reflecting the total number of high priority cases.
trigger CaseTrigger on Case (before insert, Before Delete,after insert , after update) {
   if(Trigger.isAfter){
        Set<Id> accountIds = new Set<Id>();
        Map<id,integer> highPriorityCountMap = new Map<id,integer>();
        List<Account> accUpdateList = new List<Account>();
        if(Trigger.isInsert || Trigger.isUpdate){
            for(Case cs : Trigger.new){
                if(cs.Priority == 'High' && trigger.isinsert || (Trigger.isUpdate && Trigger.oldMap.get(cs.id).priority != cs.priority)){
                    accountIds.add(cs.AccountId);
                }                   
       		 }
            
            if(!accountIds.isEmpty()){
                for(AggregateResult agg : [Select accountId accid,Count(Id) cnt from Case where AccountId in : accountIds and Priority = 'High' Group by AccountId]){
                    highPriorityCountMap.put((id)agg.get('accid'),(integer)agg.get('cnt'));
                }
                for(Account acc : [select id,High_Priority_Cases_Count__c from Account where id in : highPriorityCountMap.keyset()]){
                    acc.High_Priority_Cases_Count__c = highPriorityCountMap.get(acc.id);
                    accUpdateList.add(acc);
                }
            } 
            if(!accUpdateList.isEmpty()){
                Update accUpdateList;
            }
        }
        
    }
}
=====================================================================

Trigger 2 :
//Prevent Creation of lead if there are duplicate Lead based On email.
trigger LeadTrigger3 on Lead (Before insert) {

    if(trigger.isBefore && Trigger.isInsert){
        Set<String> emailStrings = new Set<String>();
        for(Lead ld : Trigger.new){
            if(ld.Email != null){
                emailStrings.add(ld.Email.toLowerCase());
            }
        }

        if(!emailStrings.isEmpty()){
            Map<String,Lead> leadMap = new Map<String,Lead>();
            for(Lead ld : [select id,Email from Lead where Email In : emailStrings]){
                leadMap.put(ld.Email.toLowerCase(),ld);
            }

            for(Lead ld : Trigger.new){
                if(!leadMap.isEmpty() & leadMap.containsKey(ld.Email.toLowerCase())){
                    Id leadId = leadMap.get(ld.Email).Id;
                    ld.addError('there is an already existing Lead with same Email Id : '+leadId);
                }
            }
        }
    }
}

============================================================
Trigger 3 :
 //Whenever an opportunity is created or its amount is updated or Opportunity 
 //is Deleted the related accounts total revenue should be recalculted.
      
trigger OpportunityTrigger2 on Opportunity (After Insert,After Update,after Delete) {

     if(Trigger.isAfter){

            Set<Id> accountIds = new Set<Id>();
            if(Trigger.isInsert || Trigger.isUpdate){
                for (Opportunity opp : Trigger.new) {
                    if (opp.AccountId == null) continue;
        
                    if (opp.Amount != null && (Trigger.isInsert || (Trigger.isUpdate && opp.Amount != Trigger.oldMap.get(opp.Id).Amount) || Trigger.isDelete)) {
                        accountIds.add(opp.AccountId);
                    }
                }
            }
            if(Trigger.isDelete){
                for(Opportunity opp : Trigger.old){
                    accountIds.add(opp.AccountId);
                }
            }
            
            if (!accountIds.isEmpty()){
                Map<Id, Decimal> accountRevenueMap = new Map<Id, Decimal>();
        
                for (AggregateResult ar : [
                    SELECT AccountId accId, SUM(Amount) totalAmount
                    FROM Opportunity
                    WHERE AccountId IN :accountIds
                    GROUP BY AccountId
                ]) {
                    accountRevenueMap.put((Id) ar.get('accId'),(Decimal) ar.get('totalAmount'));
                }
        
                List<Account> accountsToUpdate = new List<Account>();
        
                for (Id accId : accountIds) {
                    Decimal revenue = accountRevenueMap.containsKey(accId)? accountRevenueMap.get(accId): 0;
        
                    accountsToUpdate.add(new Account(Id = accId,AnnualRevenue = revenue));
                }
    
                if (!accountsToUpdate.isEmpty()) {
                    update accountsToUpdate;
                }
            }
    }
}

========================================================
Trigger : 4
//Child field to Parent field Update
//Update Parent Case Description details on Account description field on insert or uodate

trigger updateParentFromChild on Case (after insert,after Update) {
 
    if(Trigger.isAfter){
            if(Trigger.isInsert || Trigger.isUpdate){
                Map<Id,Case> caseIdMap = new Map<Id,Case>();
                List<Account> accUpdateList = new List<Account>();
                for(Case cs : Trigger.new){
                    if(cs.Description != null && (Trigger.isInsert || 
                    (Trigger.isUpdate && Trigger.oldMap.get(cs.id).Description != cs.Description) )){
                        caseIdMap.put(cs.AccountId, cs);
                    }
                }
                if(!caseIdMap.isEmpty()){
                    List<Account>  accList = [select id,Description1__c from Account where Id in : caseIdMap.keySet()];

                    if(!accList.isEmpty()){
                        for(Account acc : accList){
                            acc.Description1__c = caseIdMap.get(acc.id).Description;
                            accUpdateList.add(acc);
                        }
                    }
                    if(!accUpdateList.isEmpty()){
                        Update accUpdateList;
                    }
                }
            }
    }

}

=====================================================================
Trigger 5 :
//Parent to child update scenario 
//When Account description is updated update the all the child Contacts field to update.
//When Parent field Description1 is updated update all the child description field  on contacts.
trigger ParentToChildFieldUpdate on Account (After insert,After update) {
    if(Trigger.isAfter){
        if(Trigger.isInsert || Trigger.isUpdate){
            Map<Id,Account> accIdMap = new Map<Id,Account>();
            List<Contact> conListUpdate = new List<Contact>();
                for(Account acc : Trigger.new){
                    if(acc.Description1__c != null && (Trigger.isInsert || (Trigger.isUpdate && Trigger.oldMap.get(acc.id).Description1__c != acc.Description1__c))){
                        accIdMap.put(acc.id,acc);
                    }
                }
        
            if(!accIdMap.isEmpty()){
                List<Contact> conList = [select id,Description,AccountId from Contact where accountId in : accIdMap.keySet()];
                
                if(!conList.isEmpty()){
                    for(Contact con : conList){
                        con.Description = accIdMap.get(con.AccountId).Description1__c;
                        conListUpdate.add(con);
                    }
                }
                if(!conListUpdate.isEmpty()){
                    update conListUpdate;
                }
            }
        }
    }
}

==================================================================
Trigger : 6
//When Accounts total Budjet is Updated distribute it among all the Opportunities.
trigger accountTotalBudjetDistibutionOnOpps on Account (After insert,After update) {
        Map<Id,Account> accMap = new Map<Id,Account>();
        for(Account acc: Trigger.new){
            if(Trigger.isUpdate && !Trigger.oldMap.isEmpty() && acc.Total_New_Budjet__c != null && Trigger.oldMap.get(acc.id).Total_New_Budjet__c != acc.Total_New_Budjet__c){
                accMap.put(acc.id,acc);
            }
        }
        if(!accMap.isEmpty()){
            Map<Id,List<Opportunity>> accOppMap = new Map<Id,List<Opportunity>>();
            List<Opportunity> oppList = [select id,AccountId,Amount from Opportunity where AccountId in : accMap.keySet()];
            for(Opportunity opp : OppList){
                if(!accOppMap.containsKey(opp.Accountid)){
                    accOppMap.put(opp.AccountId,New List<Opportunity>());
                }
                accOppMap.get(opp.AccountId).add(opp);
            }
        
        Map<Id,decimal> budjetAccMap = new Map<Id,Decimal>();
        for(id accountId : accOppMap.keySet()){
            integer count = accOppMap.get(accountId).size();
            budjetAccMap.put(accountId,accMap.get(accountId).Total_New_Budjet__c/ count);
        }
        List<Opportunity> oppListUpdate = new List<Opportunity>();
        for(Opportunity opp: oppList){
           opp.Amount = budjetAccMap.get(opp.AccountId);
            oppListUpdate.add(opp);
        }
        if(!oppListUpdate.isEmpty()){
            Update oppListUpdate;
        }
            }
 }
===================================================================================
Trigger 7: Update Account description with phone numbers of contacts. 

trigger ContactTrigger on Contact (
    after insert,
    after update,
    after delete,
    after undelete
) {
    Set<Id> accountIds = new Set<Id>();

    // Collect Account Ids from new records
    if (Trigger.isInsert || Trigger.isUpdate || Trigger.isUndelete) {
        for (Contact con : Trigger.new) {
            if (con.AccountId != null) {
                accountIds.add(con.AccountId);
            }
        }
    }

    // Collect Account Ids from old records (for delete)
    if (Trigger.isDelete) {
        for (Contact con : Trigger.old) {
            if (con.AccountId != null) {
                accountIds.add(con.AccountId);
            }
        }
    }

    if (accountIds.isEmpty()) return;

    // Map to store AccountId → List of phone numbers
    Map<Id, List<String>> accPhoneMap = new Map<Id, List<String>>();

    // Query all related contacts
    for (Contact con : [
        SELECT AccountId, Phone
        FROM Contact
        WHERE AccountId IN :accountIds
        AND Phone != null
    ]) {
        if (!accPhoneMap.containsKey(con.AccountId)) {
            accPhoneMap.put(con.AccountId, new List<String>());
        }
        accPhoneMap.get(con.AccountId).add(con.Phone);
    }

    // Prepare Accounts for update
    List<Account> accountsToUpdate = new List<Account>();

    for (Id accId : accPhoneMap.keySet()) {
        Account acc = new Account();
        acc.Id = accId;
        acc.Description = String.join(accPhoneMap.get(accId), ', ');
        accountsToUpdate.add(acc);
    }

    if (!accountsToUpdate.isEmpty()) {
        update accountsToUpdate;
    }
}

=========================================================================
scenario 8 : 
Count how many Contacts are related to each Account.
----------------------------------------------------
//call from Anonymous window : 
Map<Id,Integer> maptt = ReturnAccountIdAndContactCount.returnAcountContactCount();
system.debug('@@mapDetails'+maptt);

public class ReturnAccountIdAndContactCount {

    public static Map<Id,Integer> returnAcountContactCount(){
        
        // Step 1: Query Contacts with AccountId
        List<Contact> contactList = [
            SELECT Id, AccountId
            FROM Contact
            WHERE AccountId != null
        ];
        
        // Step 2: Map to store AccountId → Contact Count
        Map<Id, Integer> accountContactCountMap = new Map<Id, Integer>();
        
        // Step 3: Loop through contacts and count
        for (Contact con : contactList) {
            if (accountContactCountMap.containsKey(con.AccountId)) {
                accountContactCountMap.put(
                    con.AccountId,
                    accountContactCountMap.get(con.AccountId) + 1
                );
            } else {
                accountContactCountMap.put(con.AccountId, 1);
            }
        }
        Return accountContactCountMap;
      }
}

=====================================================
Scenario 9:
Do not allow Account creation if another Account already exists with the same Name.
====================================================
trigger PreventDuplicateAccount on Account (before insert) {

    Set<String> accountNames = new Set<String>();

    // Collect incoming Account names
    for (Account acc : Trigger.new) {
        if (acc.Name != null) {
            accountNames.add(acc.Name);
        }
    }

    // Query existing Accounts with same names
    Map<String, Account> existingAccounts = new Map<String, Account>();
    for (Account acc : [
        SELECT Id, Name
        FROM Account
        WHERE Name IN :accountNames
    ]) {
        existingAccounts.put(acc.Name, acc);
    }

    // Prevent insert if duplicate found
    for (Account acc : Trigger.new) {
        if (acc.Name != null &&
            existingAccounts.containsKey(acc.Name)) {

            acc.addError(
                'An Account with the same name already exists.'
            );
        }
    }
}

===========================================================================
//Scenarion - 10
//Write a Map based logic to relate Accounts with there contacts.

Map<Id,List<Contact>> maptt = ReturnAccountIdAndContactCount.returnAcountContactCount();
system.debug('@@mapDetails'+maptt);

public class ReturnAccountIdAndContactCount {

    public static Map<Id,List<Contact>> returnAcountContactCount(){
        
        // Step 1: Query Contacts with AccountId
            List<Contact> contactList = [
                SELECT Id, Name, AccountId
                FROM Contact
                WHERE AccountId != null
            ];

            // Step 2: Create Map<AccountId, List<Contact>>
            Map<Id, List<Contact>> accountContactMap = new Map<Id, List<Contact>>();

            // Step 3: Populate the Map
            for (Contact con : contactList) {
                if (!accountContactMap.containsKey(con.AccountId)) {
                    accountContactMap.put(con.AccountId, new List<Contact>());
                }
                accountContactMap.get(con.AccountId).add(con);
            }

            // Step 4: Debug Map
            System.debug(accountContactMap);

        Return accountContactCountMap;
      }
}

==========================================================================
//Scenario - 11
//Trigger - if an Account has at least one related contact prevent the Account from being deleted.
trigger preventAccountDelete on Account(before delete){

    Set<Id> accountIds = new Set<Id>();
    for(Account acc : Trigger.old){
        accountIds.add(acc.id);
    }

    Map<Id,Integer> accContactCountMap = new Map<Id,Integer>();

    for(AggregateResult ar : [select AccountId accId, Count(Id) cnt from contact where 
                              AccountId In : accountIds Group by Accountid]){
     accContactCountMap.put((Id) ar.get('accId'),(Integer) ar.get('cnt'));           
    }
	system.debug('@@@'+accContactCountMap);
    for(Account acc : Trigger.old){
        if(!accContactCountMap.isEmpty() && accContactCountMap.containskey(acc.id)){
            acc.addError('no deletion as there are contacts in this account');
        }
    }
}

=============================================================================
//Scenario - 12
//Write an apex class to count the number of contacts per Account using map.

trigger ContactCountTrigger on Contact (after insert, after delete, after undelete) {

    Set<Id> accountIds = new Set<Id>();

    // Collect AccountIds from new records
    if (Trigger.isInsert || Trigger.isUndelete) {
        for (Contact con : Trigger.new) {
            if (con.AccountId != null) {
                accountIds.add(con.AccountId);
            }
        }
    }

    // Collect AccountIds from deleted records
    if (Trigger.isDelete) {
        for (Contact con : Trigger.old) {
            if (con.AccountId != null) {
                accountIds.add(con.AccountId);
            }
        }
    }

    if (accountIds.isEmpty()) return;

    // Count contacts per Account
    Map<Id, Integer> accountContactCountMap = new Map<Id, Integer>();

    for (AggregateResult ar : [
        SELECT AccountId accId, COUNT(Id) total
        FROM Contact
        WHERE AccountId IN :accountIds
        GROUP BY AccountId
    ]) {
        accountContactCountMap.put(
            (Id) ar.get('accId'),
            (Integer) ar.get('total')
        );
    }

    // Update Accounts
    List<Account> accountsToUpdate = new List<Account>();

    for (Id accId : accountIds) {
        Account acc = new Account();
        acc.Id = accId;
        acc.Total_Contact__c = accountContactCountMap.containsKey(accId)? accountContactCountMap.get(accId): 0;
        accountsToUpdate.add(acc);
    }

    if (!accountsToUpdate.isEmpty()) {
        update accountsToUpdate;
    }
}